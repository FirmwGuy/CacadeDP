/*
 *  Copyright (c) 2024-2025 Victor M. Barrientos
 *  (https://github.com/FirmwGuy/CacadeDP)
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy of
 *  this software and associated documentation files (the "Software"), to deal in
 *  the Software without restriction, including without limitation the rights to
 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 *  of the Software, and to permit persons to whom the Software is furnished to do
 *  so.
 *
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 *
 */


#include "cdp_system.h"
#include "domain/cdp_binary.h"


/*
  # CascadeDP Layer 2: Agents and Agencies
  
  ## Main Directory Structure
  
  ### 1. ** /system/ **
  The `/system/` dictionary stores internal information needed by the
  local record system, for example tags, names, etc.
  - **Example Structure**:
    ```
    /system/
        tag/
            1: "list"
            2: "integer"
        name/
            1: "data"
            2: "public"
        selector/
            10: "urgent"
            11: "slow"
        inhibitor/
            1: "heated"
            2: "loaded"
    ```

  ### 4. ** /user/ **
  This record serves as the personal space for user-specific
  configurations and data. Each user or administrative entity
  interacting with the nodes might have a separate entry here.
  This record may be replicated to other nodes.
  - **Example Structure**:
    ```
    /user/
        user1/
        user2/
    ```

  ### 5. ** ~/private/ **
  This record (inside a user's record) stores persistent records generated
  by agents and meant to be accessed only by the (owner) network
  user. This record is never replicated.
  - **Example Structure**:
    ```
    /user/
        user1/
            private/
                system/
                    agent01/
                        555/
                           states/
                        556/
                           states/
                        saved-data/
    ```

  ### 6. ** /public/ **
  The `/public/` record is used for storing public records generated by
  the agents in the local node. These records are advertised along
  this node when it connects to the network and may be accessed
  (and/or cached/replicated) by other nodes.
  - **Example Structure**:
    ```
    /public/
        agency001/
            measurements/
                car01/
            shared/
                count:123
                events/
    ```

  ### 7. ** /data/ **
  The `/data/` record is a virtual space used for mapping distributed
  public records into a communal coherent structure. This includes
  registers and links as shared resources that might be accessed
  within the network. This is replicated as needed.
  - **Example Structure**:
    ```
    /data/
        apps/
            agent001/
                measurements/
                    car01 -> /network/node001/public/agent001/measurements/car01
                    car02 -> /network/node002/public/agent001/measurements/car02
                shared/   -> /network/node001/public/agent001/shared/
    ```

  ### 8. ** /data/service/ **
  The `service/` record inside `/data/` contains the agent instance
  creation service (AICS) locations for available agents.
  - **Example Structure**:
    ```
    /data/
        service/
            agent001/
                node -> /network/node001/system/agent001
                node -> /network/node002/system/agent001

    ```

  ### 9. ** /network/ **
  This record is central to managing network-specific configurations
  and information about the reachability of each (foreign) connected
  node with respect to the local node.
  - **Example Structure**:
    ```
    /network/
        node001/
            protocol/
                address
                config/
                status
    ```

  ### Additional Considerations:
  - ** /data/config/ **: Maintains system-wide configuration files that affect
  all nodes and agents.
  - ** /log/ and /data/log/ **: For comprehensive logging across the system,
  which could include logs from each node, agent, and application.
  - ** /temp/ **: Temporary private records needed during execution,
  ensuring that transient data does not consume permanent storage space.

  ---
  

  ## Agencies
  
  Agencies are registered by creating a record entry in the /system/agency 
  dictionary with the DT of such agency as name.
  
  Agents are stored by their unique DT (input name) in the "inputs" dictionary 
  record inside each agency entry. The C callback function is stored as binary 
  "agent" data.
    
  In a similar way, agent outputs (named outputs) are registered by storing 
  such records in the "outputs" dictionary. Those entries are only used for 
  checking channel connection configuration and then creating respective 
  pipeline links.
  
  Tasks are stored in the "tasks" FIFO queue inside the respective agency. The 
  name of the task correspond to agency input. Tasks have an agency 
  instance link in "instance" and a "message" field with necessary task 
  data (if any).
  
    ```
    /system/
        agencies/
            my_agency01/
                inputs/
                    input_02: my_consumption_agent()
                outputs/
                    output_03
                tasks/
                    input_02/
                        instance -> instance_201
                        message/
                            argument: "01"
                description/
    ```

  ---
  

  ## Instances
  
  Agency instances may be stored anywhere. They may travel along other data 
  from machine to machine in the network. Instances are accessed only through 
  tasks.
  
  Client instance (the one owning the current pipeline) is indicated by the 
  "client" link.
  
  Owned pipelines or owned instances are **not** saved by the CDP system, so 
  the user must explicitly store such information in the persistent or similar 
  field.
  
  The instance own output linkage is stored in "outputs" dictionary, with each 
  (output) name having the target input as "CDPID" data and the target instance 
  as link. This way lookup of channels based in local output names is 
  efficient.
  
  Finally, agency own records are stored in "persistent" dictionary.
  
    ```
    /public/
        instance_01/
            agency: "my_agency02"
            client -> instance_20
            outputs/
                my_output_03
                    instance -> instance_01
                    input: "input_02"
            persistent/
                measurements/
    ```

*/


extern cdpRecord CDP_ROOT;

cdpRecord* USER;
cdpRecord* PUBLIC;
cdpRecord* DATA;
cdpRecord* NETWORK;
cdpRecord* TEMP;

cdpRecord* AGENCIES;
//cdpRecord* LIBRARY;

cdpRecord* CDP_STEP;
cdpRecord* CDP_VOID;




static void system_initiate(void) {
    cdp_record_system_initiate();

    /* Create root structure
    */
    cdpRecord* system = cdp_dict_add_dictionary(&CDP_ROOT, CDP_DTAW("CDP", "system"), CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_ARRAY, 4);

    USER    = cdp_dict_add_dictionary(&CDP_ROOT, CDP_DTAW("CDP", "user"),    CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_RED_BLACK_T);
    PUBLIC  = cdp_dict_add_dictionary(&CDP_ROOT, CDP_DTAW("CDP", "public"),  CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_RED_BLACK_T);
    DATA    = cdp_dict_add_dictionary(&CDP_ROOT, CDP_DTAW("CDP", "data"),    CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_RED_BLACK_T);
    NETWORK = cdp_dict_add_dictionary(&CDP_ROOT, CDP_DTAW("CDP", "network"), CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_RED_BLACK_T);

    TEMP    = cdp_dict_add_list(&CDP_ROOT, CDP_DTAW("CDP", "temp"), CDP_DTAW("CDP", "list"), CDP_STORAGE_LINKED_LIST);

    // Initiate system structure
    AGENCIES = cdp_dict_add_dictionary(system, CDP_DTAW("CDP", "agencies"), CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_RED_BLACK_T);
    //LIBRARY = cdp_dict_add_dictionary(system, CDP_WORD_LIBRARY, CDP_ACRO("CDP"), CDP_WORD("dictionary"), CDP_STORAGE_RED_BLACK_T);

    // Add system agents
    // cdp_system_register_agent(CDP_ACRO("CDP"), CDP_WORD("step"), agent_system_step);

    // Initiate global records.
    //cdpRecord step = {0};
    // cdp_instance_new(cdp_root(), &step, CDP_WORD("step"), CDP_ACRO("CDP"), CDP_WORD("step"), NULL, 0);
    //CDP_STEP = cdp_dict_add(AGENCIES, &step);

    //CDP_VOID = cdp_record_append_value(TEMP, CDP_WORD_VOID, CDP_ACRO("CDP"), CDP_WORD_VOID, 0, 0, sizeof(bool), sizeof(bool));
    //CDP_VOID->data->writable = false;
}


bool cdp_system_startup(void) {
    assert(AGENCIES);
    // ToDo: Traverse all records. On each record, call the "startup" agency.
    return true;
}


bool cdp_system_step(void) {
    assert(AGENCIES);

    //static uint64_t tic;

    //if CDP_RARELY(!cdp_instance_data_update(cdp_root(), CDP_STEP, sizeof(uint64_t), sizeof(uint64_t), CDP_V(tic++)))
    //    return false;

    // ToDo: traverse all agents. On each agent, do jobs listed on "work", then move them to "done".
    return true;
}


void cdp_system_shutdown(void) {
    assert(AGENCIES);

    // ToDo: Traverse all records. On each record, call the "shutdown" agency.

    //cdp_system_finalize_tasks();
    cdp_record_delete_children(&CDP_ROOT);
    cdp_record_system_shutdown();

    AGENCIES = NULL;
}




/* 
 * Agency API
 */

bool cdp_agency_register_agent(cdpDT* agency, cdpDT* input, cdpAgent agent) {
    assert(cdp_dt_valid(agency) && cdp_dt_valid(input) && agent);

    if (!AGENCIES)
        system_initiate();

    cdpRecord* ragencies = cdp_record_find_by_name(AGENCIES, agency);
    if (!ragencies) {
        // Create agency structure
        ragencies = cdp_dict_add_dictionary(AGENCIES, agency, CDP_DTAW("CDP", "agency"), CDP_STORAGE_ARRAY, 4); {
            cdp_dict_add_dictionary(ragencies, CDP_DTAW("CDP", "inputs"),  CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_RED_BLACK_T);
            cdp_dict_add_dictionary(ragencies, CDP_DTAW("CDP", "outputs"), CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_RED_BLACK_T);
            cdp_dict_add_list      (ragencies, CDP_DTAW("CDP", "tasks"),   CDP_DTAW("CDP", "queue"),      CDP_STORAGE_LINKED_LIST);
        }
    }

    cdpRecord* rinputs = cdp_record_find_by_name(ragencies, CDP_DTAW("CDP", "inputs"));     // We get 'rinputs' here because 'ragencies' is an array ('rinputs' address may become invalidated after insertions).
    
    // ToDo: check if "input" agent already exists.
    
    cdp_dict_add_binary_agent(rinputs, input, agent);

    return true;
}


bool cdp_agency_set_output(cdpDT* agency, cdpDT* output) {
    assert(cdp_dt_valid(agency) && cdp_dt_valid(output));
    if CDP_NOT_ASSERT(AGENCIES)
        return false;

    cdpRecord* ragencies = cdp_record_find_by_name(AGENCIES, agency);
    if CDP_NOT_ASSERT(ragencies)
        return false;
        
    cdpRecord* routputs = cdp_record_find_by_name(ragencies, CDP_DTAW("CDP", "outputs"));

    if (!cdp_record_find_by_name(routputs, output)) {
        cdp_dict_add_empty(routputs, output);       // Outputs are just present by name (no other data is needed present so far).
    }

    return true;
}


cdpRecord* cdp_record_add_agency_instance(  cdpRecord* record, cdpDT* name, uintptr_t context,
                                            cdpDT* agency, cdpRecord* args, cdpRecord* client   ) {
    assert(!cdp_record_is_floating(record) && cdp_dt_valid(name) && cdp_dt_valid(agency) && cdp_agency_instance_valid(client));
    if CDP_NOT_ASSERT(AGENCIES)
        return NULL;

    // Create instance structure
    cdpRecord* instance = cdp_record_add_dictionary(record, name, context, CDP_DTAW("CDP", "instance"), CDP_STORAGE_ARRAY, 4); {
        cdp_dict_add_binary_dt (instance, CDP_DTAW("CDP", "agency"),     agency);
        cdp_dict_add_link      (instance, CDP_DTAW("CDP", "client"),     client);
        cdp_dict_add_dictionary(instance, CDP_DTAW("CDP", "outputs"),    CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_RED_BLACK_T);
        cdp_dict_add_dictionary(instance, CDP_DTAW("CDP", "persistent"), CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_RED_BLACK_T);
    }

    cdp_agency_instance_message(instance, CDP_DTAW("CDP", "initialize"), args);

    return instance;
}


bool cdp_agency_instance_message(cdpRecord* instance, cdpDT* input, cdpRecord* message) {
    assert(cdp_agency_instance_valid(instance) && cdp_dt_valid(input));
    if CDP_NOT_ASSERT(AGENCIES)
        return false;
    
    cdpDT* agency = cdp_record_data_find_by_name(instance, CDP_DTAW("CDP", "agency"));
    if CDP_NOT_ASSERT(agency)
        return false;
    
    cdpRecord* ragency = cdp_record_find_by_name(AGENCIES, agency);
    if CDP_NOT_ASSERT(ragency)
        return false;
                
    cdpRecord* rtasks = cdp_record_find_by_name(ragency, CDP_DTAW("CDP", "tasks"));
    if CDP_NOT_ASSERT(rtasks)
        return false;
    
    // Create task structure
    cdpRecord task = {0};
    cdp_record_initialize_dictionary(&task, input, CDP_DTAW("CDP", "task"), CDP_STORAGE_ARRAY, 2); {
        cdp_dict_add_link(&task, CDP_DTAW("CDP", "instance"), instance);
        cdpRecord* rmessage = cdp_dict_add_list(&task, CDP_DTAW("CDP", "message"), CDP_DTAW("CDP", "list"), CDP_STORAGE_LINKED_LIST); {
            if (message)
                cdp_record_append(rmessage, false, message);
        }
    }
    
    cdp_record_append(rtasks, false, &task);
            
    return true;
}


void cdp_agency_instance_dispose(cdpRecord* instance) {
    assert(cdp_agency_instance_valid(instance));
    
    cdp_agency_instance_message(instance, CDP_DTAW("CDP", "finalize"), NULL);
    
    // ToDo: catch "finalize" tasks and delete actual instance.
}


bool cdp_agency_client_message(cdpRecord* selfI, cdpDT* input, cdpRecord* message) {
    assert(cdp_agency_instance_valid(selfI));
    
    cdpRecord* rclient = cdp_record_find_by_name(selfI, CDP_DTAW("CDP", "client"));
    if (!rclient)
        return false;

    return cdp_agency_instance_message(rclient, input, message);
}


bool cdp_agency_output_connect(cdpRecord* sourceI, cdpDT* output, cdpRecord* targetI, cdpDT* input) {
    assert(cdp_agency_instance_valid(sourceI) && cdp_agency_instance_valid(targetI));
    assert(cdp_dt_valid(output) && cdp_dt_valid(input));

    // Create channel structure (message):
    cdpRecord channel = {0};
    cdp_record_initialize_dictionary(&channel, CDP_DTAW("CDP", "channel"), CDP_DTAW("CDP", "channel"), CDP_STORAGE_ARRAY, 3); {
        cdp_dict_add_binary_dt(&channel, CDP_DTAW("CDP", "input"),  input);
        cdp_dict_add_binary_dt(&channel, CDP_DTAW("CDP", "output"), output);
        cdp_dict_add_link     (&channel, CDP_DTAW("CDP", "target"), targetI);
    }

    cdp_agency_instance_message(sourceI, CDP_DTAW("CDP", "connect"), &channel);

    // ToDo: convert output entry in list (with a FLEX record).
    
    // ToDo: catch "connect" task to actually finish storing in instance record.

    return true;
}


bool cdp_agency_output_message(cdpRecord* selfI, cdpDT* output, cdpRecord* message) {
    assert(cdp_agency_instance_valid(selfI) && cdp_dt_valid(output));

    cdpRecord* routputs = cdp_record_find_by_name(selfI, CDP_DTAW("CDP", "outputs"));
    if CDP_NOT_ASSERT(routputs)
        return false;
    
    cdpRecord* out = cdp_record_find_by_name(routputs, output);
    if (!out) {
        cdp_record_dispose(message);
        return true;
    }
    
    cdpDT* input = cdp_record_data_find_by_name(out, CDP_DTAW("CDP", "input"));
    if CDP_NOT_ASSERT(input)
        return false;
    
    cdpRecord* rtarget = cdp_record_find_by_name(out, CDP_DTAW("CDP", "target"));
    if CDP_NOT_ASSERT(rtarget)
        return false;
        
    cdpRecord* target = cdp_link_pull(rtarget);
    
    // ToDo: handle multiple outputs.
    
    return cdp_agency_instance_message(target, input, message);
}




/* Agent: 'System Step'
 *
 * It generates an output each time the system is ready for another execution
 * step. Agents needing cooperative coroutine behaviour should connect to this.
 * If a base time is specified in the instance then System Step will sleep the
 * remaining time after completion (if any) to keep things in sync.
 *
 * Output:
 *      CDPID: a dynamically named event output.
 *
 * Config:
 *      'base-time':
 *
 */

static bool system_agent_step(cdpRecord* instance, cdpDT* input, cdpRecord* message) {
    

    return true;
}






