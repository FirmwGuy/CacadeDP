/*
 *  Copyright (c) 2024-2025 Victor M. Barrientos
 *  (https://github.com/FirmwGuy/CacadeDP)
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy of
 *  this software and associated documentation files (the "Software"), to deal in
 *  the Software without restriction, including without limitation the rights to
 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 *  of the Software, and to permit persons to whom the Software is furnished to do
 *  so.
 *
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 *
 */


#include "cdp_system.h"
#include "domain/cdp_binary.h"


/*
  # CascadeDP Layer 2: Agents and Agencies
  
  ## Main Directory Structure
  
  ### 1. ** /system/ **
  The `/system/` dictionary stores internal information needed by the
  local record system, for example tags, names, etc.
  - **Example Structure**:
    ```
    /system/
        tag/
            1: "list"
            2: "integer"
        name/
            1: "data"
            2: "public"
        selector/
            10: "urgent"
            11: "slow"
        inhibitor/
            1: "heated"
            2: "loaded"
    ```

  ### 4. ** /user/ **
  This record serves as the personal space for user-specific
  configurations and data. Each user or administrative entity
  interacting with the nodes might have a separate entry here.
  This record may be replicated to other nodes.
  - **Example Structure**:
    ```
    /user/
        user1/
        user2/
    ```

  ### 5. ** ~/private/ **
  This record (inside a user's record) stores persistent records generated
  by agents and meant to be accessed only by the (owner) network
  user. This record is never replicated.
  - **Example Structure**:
    ```
    /user/
        user1/
            private/
                system/
                    agent01/
                        555/
                           states/
                        556/
                           states/
                        saved-data/
    ```

  ### 6. ** /public/ **
  The `/public/` record is used for storing public records generated by
  the agents in the local node. These records are advertised along
  this node when it connects to the network and may be accessed
  (and/or cached/replicated) by other nodes.
  - **Example Structure**:
    ```
    /public/
        agency001/
            measurements/
                car01/
            shared/
                count:123
                events/
    ```

  ### 7. ** /data/ **
  The `/data/` record is a virtual space used for mapping distributed
  public records into a communal coherent structure. This includes
  registers and links as shared resources that might be accessed
  within the network. This is replicated as needed.
  - **Example Structure**:
    ```
    /data/
        apps/
            agent001/
                measurements/
                    car01 -> /network/node001/public/agent001/measurements/car01
                    car02 -> /network/node002/public/agent001/measurements/car02
                shared/   -> /network/node001/public/agent001/shared/
    ```

  ### 8. ** /data/service/ **
  The `service/` record inside `/data/` contains the agent instance
  creation service (AICS) locations for available agents.
  - **Example Structure**:
    ```
    /data/
        service/
            agent001/
                node -> /network/node001/system/agent001
                node -> /network/node002/system/agent001

    ```

  ### 9. ** /network/ **
  This record is central to managing network-specific configurations
  and information about the reachability of each (foreign) connected
  node with respect to the local node.
  - **Example Structure**:
    ```
    /network/
        node001/
            protocol/
                address
                config/
                status
    ```

  ### Additional Considerations:
  - ** /data/config/ **: Maintains system-wide configuration files that affect
  all nodes and agents.
  - ** /log/ and /data/log/ **: For comprehensive logging across the system,
  which could include logs from each node, agent, and application.
  - ** /temp/ **: Temporary private records needed during execution,
  ensuring that transient data does not consume permanent storage space.

  ---
  

  ## Agencies
  
  Agencies are registered by creating a record entry in the /system/agency 
  catalog with the domain-tag (DT) of such agency as a key; the domain is used 
  as record name and tag is stored as binary "CDPID" data.
  
  Agents are stored by their unique DT (input name) in the "input" 
  dictionary record inside each agency entry. Since the domain is the same as 
  the parent agency, only the tag is used as unique name. The C callback 
  function is stored as binary "agent" data.
    
  In a similar way, agent outputs (named outputs) are registered by storing 
  such records in the "input" dictionary. Productions are only used for 
  checking channel connection configuration and then creating respective 
  pipeline links.
  
  Tasks are stored in the "task" FIFO queue inside the respective agency. The 
  name of the task correspond to agency input. Tasks have an agency 
  instance link in "instance" record and "message" field with necessary task 
  data (if any).
  
    ```
    /system/
        agencies/
            my_agency01/
                inputs/
                    input_02: my_consumption_agent()
                outputs/
                    output_03
                tasks/
                    input_02/
                        instance -> instance_201
                        message/
                            argument: "01"
                description/
    ```

  ---
  

  ## Instances
  
  Agency instances may be stored anywhere. They may travel along other data 
  from machine to machine in the network. Instances are accessed only through 
  tasks.
  
  Client instance (the one owning this pipeline) is indicated by the "client"
  link.
  
  Owned pipelines are stored inside client instances in their "pipeline" queue. 
  Each pipeline is not a collection of instances, but rather is a dictionary of 
  channels defining which agency instance named output becomes the named input 
  of which other instance.
  
  Here, instances are just links to actual agency instances, while output 
  and input are refered only by their DT. Channel names are arbitrary and 
  may be set by the user or automatically by the CDP system.
  
  The instance own output linkage (as defined by its parent client pipeline) is 
  stored in "output" dictionary, with each (output) name having the target 
  input as "CDPID" data and the target instance as link. This way lookup of 
  channels based in local output names is efficient.
  
  Finally, agency records are stored in "persistent" dictionary.
  
    ```
    /public/
        instance_01/
            agency: "my_agency02"
            client -> instance_20
            outputs/
                my_output_03
                    agency: "my_agency01"
                    input: "input_02"
                    instance -> instance_01
            persistent/
                measurements/
            pipelines/
                child-pipe-05/
                    instances/
                        my_instance01 -> instance_02
                        my_instance02 -> instance_03
                    channels/
                        channel_06/
                            source -> instance_02
                            output: "output_01"
                            target -> instance_03
                            input: "input_01"
    ```

*/


extern cdpRecord CDP_ROOT;

cdpRecord* USER;
cdpRecord* PUBLIC;
cdpRecord* DATA;
cdpRecord* NETWORK;
cdpRecord* TEMP;

cdpRecord* AGENCIES;
//cdpRecord* LIBRARY;

cdpRecord* CDP_STEP;
cdpRecord* CDP_VOID;




static void system_initiate(void) {
    cdp_record_system_initiate();

    /* Create root structure
    */
    cdpRecord* system  = cdp_dict_add_dictionary(&CDP_ROOT, CDP_DTAW("CDP", "system"),  CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_ARRAY, 4);

    USER    = cdp_dict_add_dictionary(&CDP_ROOT, CDP_DTAW("CDP", "user"),    CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_RED_BLACK_T);
    PUBLIC  = cdp_dict_add_dictionary(&CDP_ROOT, CDP_DTAW("CDP", "public"),  CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_RED_BLACK_T);
    DATA    = cdp_dict_add_dictionary(&CDP_ROOT, CDP_DTAW("CDP", "data"),    CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_RED_BLACK_T);
    NETWORK = cdp_dict_add_dictionary(&CDP_ROOT, CDP_DTAW("CDP", "network"), CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_RED_BLACK_T);

    TEMP    = cdp_dict_add_list(&CDP_ROOT, CDP_DTAW("CDP", "temp"), CDP_DTAW("CDP", "list"), CDP_STORAGE_LINKED_LIST);

    // Initiate system structure
    AGENCIES = cdp_record_add_dictionary(system, CDP_DTAW("CDP", "agencies"), 0, CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_RED_BLACK_T);
    //LIBRARY = cdp_dict_add_dictionary(system, CDP_WORD_LIBRARY, CDP_ACRO("CDP"), CDP_WORD("dictionary"), CDP_STORAGE_RED_BLACK_T);

    // Add system agents
    // cdp_system_register_agent(CDP_ACRO("CDP"), CDP_WORD("step"), agent_system_step);

    // Initiate global records.
    //cdpRecord step = {0};
    // cdp_instance_new(cdp_root(), &step, CDP_WORD("step"), CDP_ACRO("CDP"), CDP_WORD("step"), NULL, CDP_V(0));
    //CDP_STEP = cdp_dict_add(AGENCIES, &step);

    //CDP_VOID = cdp_record_append_value(TEMP, CDP_WORD_VOID, CDP_ACRO("CDP"), CDP_WORD_VOID, 0, 0, sizeof(bool), sizeof(bool));
    //CDP_VOID->data->writable = false;
}


bool cdp_system_startup(void) {
    assert(AGENCIES);
    // ToDo: Traverse all records. On each record, call the "startup" agency.
    return true;
}


bool cdp_system_step(void) {
    assert(AGENCIES);

    //static uint64_t tic;

    //if CDP_RARELY(!cdp_instance_data_update(cdp_root(), CDP_STEP, sizeof(uint64_t), sizeof(uint64_t), CDP_V(tic++)))
    //    return false;

    // ToDo: traverse all agents. On each agent, do jobs listed on "work", then move them to "done".
    return true;
}


void cdp_system_shutdown(void) {
    assert(AGENCIES);

    // ToDo: Traverse all records. On each record, call the "shutdown" agency.

    //cdp_system_finalize_tasks();
    cdp_record_delete_children(&CDP_ROOT);
    cdp_record_system_shutdown();

    AGENCIES = NULL;
}




/* 
 * Agency API
 */

bool cdp_agency_set_agent(cdpDT* agency, cdpDT* input, cdpAgent agent) {
    assert(cdp_dt_valid(agency) && cdp_dt_valid(input) && agent);

    if (!AGENCIES)
        system_initiate();

    cdpRecord* ragencies = cdp_record_find_by_name(AGENCIES, agency);
    if (!ragencies) {
        // Create agency structure
        ragencies = cdp_dict_add_dictionary(AGENCIES, agency, CDP_DTAW("CDP", "agency"), CDP_STORAGE_ARRAY, 4); {
            cdp_dict_add_dictionary(ragencies, CDP_DTAW("CDP", "inputs"),  CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_RED_BLACK_T);
            cdp_dict_add_dictionary(ragencies, CDP_DTAW("CDP", "outputs"), CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_RED_BLACK_T);
            cdp_dict_add_list      (ragencies, CDP_DTAW("CDP", "tasks"),   CDP_DTAW("CDP", "queue"),      CDP_STORAGE_LINKED_LIST);
        }
    }

    cdpRecord* rinputs = cdp_record_find_by_name(ragencies, CDP_DTAW("CDP", "inputs"));     // We get 'rinputs' here because 'ragencies' is an array ('rinputs' address may become invalidated after insertions).
    // ToDo: check if "input" agent already exists.
    
    cdp_dict_add_binary_agent(rinputs, input, agent);

    return true;
}


bool cdp_agency_set_output(cdpDT* agency, cdpDT* output) {
    assert(cdp_dt_valid(agency) && cdp_dt_valid(output));
    if CDP_NOT_ASSERT(AGENCIES)
        return false;

    cdpRecord* ragencies = cdp_record_find_by_name(AGENCIES, agency);
    if CDP_NOT_ASSERT(ragencies)
        return false;
        
    routputs = cdp_record_find_by_name(ragencies, CDP_DTAW("CDP", "outputs"));

    // Outputs are just present by name; no data or agent pointer is needed here.
    if (!cdp_record_find_by_name(routputs, output)) {
        cdp_dict_add_empty(routputs, output);
    }

    return true;
}


cdpRecord* cdp_record_add_agency_instance(  cdpRecord* record, cdpDT* name, uintptr_t context,
                                            cdpDT* agency, cdpRecord* args, cdpRecord* client   ) {
    assert(!cdp_record_is_floating(record) && cdp_dt_valid(name) && cdp_dt_valid(agency) && cdp_agency_instance_valid(client));
    if CDP_NOT_ASSERT(AGENCIES)
        return NULL;

    // Create instance structure
    cdpRecord* instance = cdp_record_add_dictionary(record, name, context, CDP_DTAW("CDP", "instance"), CDP_STORAGE_ARRAY, 5); {
        cdp_dict_add_binary_dt (instance, CDP_DTAW("CDP", "agency"),     agency);
        cdp_dict_add_link      (instance, CDP_DTAW("CDP", "client"),     client);
        cdp_dict_add_dictionary(instance, CDP_DTAW("CDP", "outputs"),    CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_RED_BLACK_T);
        cdp_dict_add_dictionary(instance, CDP_DTAW("CDP", "persistent"), CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_RED_BLACK_T);
        cdp_dict_add_dictionary(instance, CDP_DTAW("CDP", "pipelines"),  CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_RED_BLACK_T);
    }

    cdp_agency_instance_message(instance, CDP_DTAW("CDP", "initialize"), args);

    return instance;
}


bool cdp_agency_instance_message(cdpRecord* instance, cdpDT* input, cdpRecord* message) {
    assert(cdp_agency_instance_valid(instance) && cdp_dt_valid(input));
    if CDP_NOT_ASSERT(AGENCIES)
        return false;
    
    cdpDT* agency = cdp_record_data_find_by_name(instance, CDP_DTAW("CDP", "agency"));
    if CDP_NOT_ASSERT(agency)
        return false;
    
    cdpRecord* ragencies = cdp_record_find_by_name(AGENCIES, agency);
    if CDP_NOT_ASSERT(ragencies)
        return false;
                
    cdpRecord* rtasks = cdp_record_find_by_name(ragencies, CDP_DTAW("CDP", "tasks"));
    if CDP_NOT_ASSERT(rtasks)
        return false;
    
    // Create task structure
    cdpRecord task = {0};
    cdp_record_initialize_dictionary(&task, input, CDP_DTAW("CDP", "task"), CDP_STORAGE_ARRAY, 2); {
        cdp_dict_add_link(&task, CDP_DTAW("CDP", "instance"), instance);
        cdpRecord* rmessage = cdp_dict_add_list(&task, CDP_DTAW("CDP", "message"), CDP_DTAW("CDP", "list"), CDP_STORAGE_LINKED_LIST);
        if (message)
            cdp_record_append(rmessage, false, message);
    }
    
    cdp_record_append(rtasks, false, &task);
            
    return true;
}


void cdp_agency_instance_dispose(cdpRecord* instance) {
    assert(cdp_agency_instance_valid(instance));
    
    cdp_agency_instance_message(instance, CDP_DTAW("CDP", "finalize"), NULL);
    
    // ToDo: catch "finalize" tasks and delete actual instance.
}


bool cdp_agency_pipeline_create(cdpRecord* selfI, cdpDT* name) {
    assert(cdp_agency_instance_valid(selfI) && cdp_dt_valid(name));

    cdpRecord* rpipelines = cdp_record_find_by_name(selfI, CDP_DTAW("CDP", "pipelines"));
    if CDP_NOT_ASSERT(rpipelines)
        return false;
        
    cdpRecord* previous = cdp_record_find_by_name(rpipelines, name);
    if (!previous) {
        // Create pipeline structure
        cdpRecord* pl = cdp_dict_add_dictionary(rpipelines, name, CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_RED_BLACK_T); {
            cdp_dict_add_dictionary(pl, CDP_DTAW("CDP", "instances"), CDP_DTAW("CDP", "list"), CDP_STORAGE_LINKED_LIST);
            cdp_dict_add_dictionary(pl, CDP_DTAW("CDP", "channels"),  CDP_DTAW("CDP", "list"), CDP_STORAGE_LINKED_LIST);
        }
    }

    return true;
}


struct _IM {
    cdpDT*      input;
    cdpRecord*  message;
};

static inline bool agency_pipeline_traverse(cdpEntry* entry, struct _IM* im) {
    
    cdpRecord* instance = ;
    
    return cdp_agency_instance_message(instance, im->input, im->message);
}

bool cdp_agency_pipeline_message(cdpRecord* selfI, cdpDT* pipeline, cdpDT* input, cdpRecord* message) {
    assert(cdp_agency_instance_valid(selfI) && cdp_dt_valid(pipeline) && cdp_dt_valid(input));

    cdpRecord* rpipelines = cdp_record_find_by_name(selfI, CDP_DTAW("CDP", "pipelines"));
    if (!rpipelines)
        return false;

    cdpRecord* pl = cdp_record_find_by_name(rpipelines, pipeline);
    if (!pl)
        return false;

    struct _SM sm = {.input = input, .message = message};
    cdpEntry entry = {0};
    cdp_record_traverse(pl, agency_pipeline_traverse, &sm, &entry);

    return true;
}


bool cdp_agency_pipeline_dispose(cdpRecord* selfI, cdpDT* pipeline) {
    assert(cdp_agency_instance_valid(selfI) && cdp_dt_valid(pipeline));

    cdpRecord* rpipelines = cdp_record_find_by_name(selfI, CDP_DTAW("CDP", "pipelines"));
    if (!rpipelines)
        return false;

    cdpRecord* pl = cdp_record_find_by_name(rpipelines, pipeline);
    if (!pl)
        return false;
    
    // ToDo: send a signal to each unique instance
    {
        cdp_agency_instance_dispose(instance);
    }

    cdp_record_delete(pl);

    return true;
}


bool cdp_agency_client_message(cdpRecord* selfI, cdpDT* input, cdpRecord* message) {
    assert(cdp_agency_instance_valid(selfI));
    
    cdpRecord* rclient = cdp_record_find_by_name(selfI, CDP_DTAW("CDP", "client"));
    if (!rclient)
        return false;

    return cdp_agency_instance_message(rclient, input, message);
}


bool cdp_agency_output_connect( cdpRecord* selfI, cdpDT* pipeline, 
                                cdpRecord* sourceI, cdpDT* output,
                                cdpRecord* targetI, cdpDT* input    ) {
    assert(cdp_agency_instance_valid(selfI) && cdp_agency_instance_valid(sourceI) && cdp_agency_instance_valid(targetI));
    assert(cdp_dt_valid(pipeline) && cdp_dt_valid(output) && cdp_dt_valid(input));
    
    cdpRecord* rpipelines = cdp_record_find_by_name(selfI, CDP_DTAW("CDP", "pipelines"));
    if CDP_NOT_ASSERT(rpipelines)
        return false;

    cdpRecord* pl = cdp_record_find_by_name(rpipelines, pipeline);
    if CDP_NOT_ASSERT(pl)
        return false;

    cdpRecord* rinstances = cdp_record_find_by_name(pl, CDP_DTAW("CDP", "instances"));
    if CDP_NOT_ASSERT(rinstances)
        return false;
    
    cdpRecord* instance = cdp_record_find_by_name(pl, CDP_DTAW("CDP", "instances"));
    if (!instance)
        cdp_record_add_link(rinstances, , 0, sourceI);
    
    instance = cdp_record_find_by_name(pl, CDP_DTAW("CDP", "instances"));
    if (!instance)
        cdp_record_add_link(rinstances, , 0, targetI);

    cdpRecord* rchannels = cdp_record_find_by_name(pl, CDP_DTAW("CDP", "channels"));
    if CDP_NOT_ASSERT(rchannels)
        return false;
    
    // ToDo: check if instances are already connected (same I/O).
            
    // Create channel structure
   cdpRecord* channel = cdp_dict_add_dictionary(rchannels, CDP_AUTOID, CDP_DTAW("CDP", "channel"), CDP_STORAGE_ARRAY, 4); {
        cdp_dict_add_binary_dt(&channel, CDP_DTAW("CDP", "input"),  input);
        cdp_dict_add_binary_dt(&channel, CDP_DTAW("CDP", "output"), output);
        cdp_dict_add_link     (&channel, CDP_DTAW("CDP", "source"), sourceI);
        cdp_dict_add_link     (&channel, CDP_DTAW("CDP", "target"), targetI);
    }

    // Create connection structure (almost the same as channel)
    cdpRecord* connection = {0};
    cdp_record_initialize_dictionary(&connection, CDP_DTAW("CDP", "channel"), CDP_DTAW("CDP", "dictionary"), CDP_STORAGE_ARRAY, 3); {
        cdp_dict_add_binary_dt(&connection, CDP_DTAW("CDP", "input"),  input);
        cdp_dict_add_binary_dt(&connection, CDP_DTAW("CDP", "output"), output);
        cdp_dict_add_link     (&connection, CDP_DTAW("CDP", "target"), targetI);
    }

    cdp_agency_instance_message(sourceI, CDP_DTAW("CDP", "connect"), connection);

    // ToDo: convert output entry in list (with a FLEX record).
    
    // ToDo: catch "connect" task to actually finish storing in instance record.

    return true;
}


bool cdp_agency_output_message(cdpRecord* selfI, cdpDT* output, cdpRecord* message) {
    assert(cdp_agency_instance_valid(selfI) && cdp_dt_valid(output));

    cdpRecord* routputs = cdp_record_find_by_name(selfI, CDP_DTAW("CDP", "outputs"));
    if (!routputs) {
        assert(routputs);
        return false;
    }
    
    cdpRecord* out = cdp_record_find_by_name(routputs, output);
    if (!out) {
        cdp_record_dispose(message);
        return true;
    }
    
    cdpRecord* rtarget = cdp_record_find_by_name(out, CDP_DTAW("CDP", "target"));
    cdpRecord* target = cdp_link_pull(rtarget);
    
    cdpRecord* rinput = cdp_record_find_by_name(out, CDP_DTAW("CDP", "input"));
    cdpDT* input = cdp_record_data(rinput);
    
    return cdp_agency_instance_message(target, input, message);
}




/* Agent: 'System Step'
 *
 * It generates an output each time the system is ready for another execution
 * step. Agents needing cooperative coroutine behaviour should connect to this.
 * If a base time is specified in the instance then System Step will sleep the
 * remaining time after completion (if any) to keep things in sync.
 *
 * Output:
 *      CDPID: a dynamically named event output.
 *
 * Config:
 *      'base-time':
 *
 */
struct _step {
    cdpRecord*  client;
    cdpValue    tic;
};

static inline bool agent_step_on_each_output(cdpEntry* entry, struct _step* step){
    cdp_instance_data_update(step->client, entry->record, sizeof(step->tic), sizeof(step->tic), step->tic);
    return false;
}

static int agent_system_step(cdpRecord* pipeline, cdpRecord* instance, cdpRecord* record, unsigned action) {
    assert(client && self);

    switch (action) {
      case CDP_ACTION_INSTANCE_NEW: {
        cdp_record_set_data(self, cdp_data_new_binary_uint64(0));
        cdp_record_set_store(self, cdp_store_new(CDP_ACRO("CDP"), CDP_WORD("list"), CDP_STORAGE_LINKED_LIST, CDP_INDEX_BY_INSERTION));
        return CDP_STATUS_SUCCESS;
      }

      case CDP_ACTION_INSTANCE_CONNECT: {
        cdpRecord* link = cdp_record_append_link(self, CDP_AUTOID, record);
        CDP_PTR_SEC_SET(returned, link);
        return CDP_STATUS_SUCCESS;
      }

      case CDP_ACTION_INSTANCE_UNPLUG: {
        assert(self == cdp_record_parent(record));
        cdp_record_remove(record, NULL);
        return CDP_STATUS_SUCCESS;
      }

      case CDP_ACTION_DATA_UPDATE: {
        struct _step step = {.client = self, .tic = value};
        cdpEntry entry = {0};
        if (true == cdp_record_traverse(self, (cdpTraverse) agent_step_on_each_output, &step, &entry))
            return CDP_STATUS_FAIL;
        return CDP_STATUS_SUCCESS;
      }
    }

    return CDP_STATUS_OK;
}






